diff --git a/teensy3/usb_desc.c b/teensy3/usb_desc.c
index dba582d..15e7b50 100644
--- a/teensy3/usb_desc.c
+++ b/teensy3/usb_desc.c
@@ -234,6 +234,55 @@ static uint8_t joystick_report_desc[] = {
 };
 #endif
 
+// This is identical to JOYSTICK_INTERFACE (besides the variable name)
+// but I'd like to keep the MultiJoy code as separate as possible for now
+#ifdef MULTIJOY_INTERFACE
+static uint8_t multijoy_report_desc[] = {
+        0x05, 0x01,                     // Usage Page (Generic Desktop)
+        0x09, 0x04,                     // Usage (Joystick)
+        0xA1, 0x01,                     // Collection (Application)
+        0x15, 0x00,                     // Logical Minimum (0)
+        0x25, 0x01,                     // Logical Maximum (1)
+        0x75, 0x01,                     // Report Size (1)
+        0x95, 0x20,                     // Report Count (32)
+        0x05, 0x09,                     // Usage Page (Button)
+        0x19, 0x01,                     // Usage Minimum (Button #1)
+        0x29, 0x20,                     // Usage Maximum (Button #32)
+        0x81, 0x02,                     // Input (variable,absolute)
+        0x15, 0x00,                     // Logical Minimum (0)
+        0x25, 0x07,                     // Logical Maximum (7)
+        0x35, 0x00,                     // Physical Minimum (0)
+        0x46, 0x3B, 0x01,               // Physical Maximum (315)
+        0x75, 0x04,                     // Report Size (4)
+        0x95, 0x01,                     // Report Count (1)
+        0x65, 0x14,                     // Unit (20)
+        0x05, 0x01,                     // Usage Page (Generic Desktop)
+        0x09, 0x39,                     // Usage (Hat switch)
+        0x81, 0x42,                     // Input (variable,absolute,null_state)
+        0x05, 0x01,                     // Usage Page (Generic Desktop)
+        0x09, 0x01,                     // Usage (Pointer)
+        0xA1, 0x00,                     // Collection ()
+        0x15, 0x00,                     //   Logical Minimum (0)
+        0x26, 0xFF, 0x03,               //   Logical Maximum (1023)
+        0x75, 0x0A,                     //   Report Size (10)
+        0x95, 0x04,                     //   Report Count (4)
+        0x09, 0x30,                     //   Usage (X)
+        0x09, 0x31,                     //   Usage (Y)
+        0x09, 0x32,                     //   Usage (Z)
+        0x09, 0x35,                     //   Usage (Rz)
+        0x81, 0x02,                     //   Input (variable,absolute)
+        0xC0,                           // End Collection
+        0x15, 0x00,                     // Logical Minimum (0)
+        0x26, 0xFF, 0x03,               // Logical Maximum (1023)
+        0x75, 0x0A,                     // Report Size (10)
+        0x95, 0x02,                     // Report Count (2)
+        0x09, 0x36,                     // Usage (Slider)
+        0x09, 0x36,                     // Usage (Slider)
+        0x81, 0x02,                     // Input (variable,absolute)
+        0xC0                            // End Collection
+};
+#endif
+
 #ifdef SEREMU_INTERFACE
 static uint8_t seremu_report_desc[] = {
         0x06, 0xC9, 0xFF,                       // Usage Page 0xFFC9 (vendor defined)
@@ -667,6 +716,124 @@ static uint8_t config_descriptor[CONFIG_DESC_SIZE] = {
         JOYSTICK_INTERVAL,                      // bInterval
 #endif // JOYSTICK_INTERFACE
 
+#ifdef MULTIJOY_INTERFACE
+        #if MULTIJOY_COUNT > 0
+                // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
+                9,                                      // bLength
+                4,                                      // bDescriptorType
+                (MULTIJOY_INTERFACE + 0)                // bInterfaceNumber
+                0,                                      // bAlternateSetting
+                1,                                      // bNumEndpoints
+                0x03,                                   // bInterfaceClass (0x03 = HID)
+                0x00,                                   // bInterfaceSubClass
+                0x00,                                   // bInterfaceProtocol
+                0,                                      // iInterface
+                // HID interface descriptor, HID 1.11 spec, section 6.2.1
+                9,                                      // bLength
+                0x21,                                   // bDescriptorType
+                0x11, 0x01,                             // bcdHID
+                0,                                      // bCountryCode
+                1,                                      // bNumDescriptors
+                0x22,                                   // bDescriptorType
+                LSB(sizeof(multijoy_report_desc)),      // wDescriptorLength
+                MSB(sizeof(multijoy_report_desc)),
+                // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
+                7,                                      // bLength
+                5,                                      // bDescriptorType
+                (MULTIJOY_ENDPOINT + 0) | 0x80,         // bEndpointAddress
+                0x03,                                   // bmAttributes (0x03=intr)
+                MULTIJOY_SIZE, 0,                       // wMaxPacketSize
+                MULTIJOY_INTERVAL,                      // bInterval
+        #endif
+        #if MULTIJOY_COUNT > 1
+                // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
+                9,                                      // bLength
+                4,                                      // bDescriptorType
+                (MULTIJOY_INTERFACE + 1)                // bInterfaceNumber
+                0,                                      // bAlternateSetting
+                1,                                      // bNumEndpoints
+                0x03,                                   // bInterfaceClass (0x03 = HID)
+                0x00,                                   // bInterfaceSubClass
+                0x00,                                   // bInterfaceProtocol
+                0,                                      // iInterface
+                // HID interface descriptor, HID 1.11 spec, section 6.2.1
+                9,                                      // bLength
+                0x21,                                   // bDescriptorType
+                0x11, 0x01,                             // bcdHID
+                0,                                      // bCountryCode
+                1,                                      // bNumDescriptors
+                0x22,                                   // bDescriptorType
+                LSB(sizeof(multijoy_report_desc)),      // wDescriptorLength
+                MSB(sizeof(multijoy_report_desc)),
+                // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
+                7,                                      // bLength
+                5,                                      // bDescriptorType
+                (MULTIJOY_ENDPOINT + 1) | 0x80,         // bEndpointAddress
+                0x03,                                   // bmAttributes (0x03=intr)
+                MULTIJOY_SIZE, 0,                       // wMaxPacketSize
+                MULTIJOY_INTERVAL,                      // bInterval
+        #endif
+        #if MULTIJOY_COUNT > 2
+                // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
+                9,                                      // bLength
+                4,                                      // bDescriptorType
+                (MULTIJOY_INTERFACE + 2)                // bInterfaceNumber
+                0,                                      // bAlternateSetting
+                1,                                      // bNumEndpoints
+                0x03,                                   // bInterfaceClass (0x03 = HID)
+                0x00,                                   // bInterfaceSubClass
+                0x00,                                   // bInterfaceProtocol
+                0,                                      // iInterface
+                // HID interface descriptor, HID 1.11 spec, section 6.2.1
+                9,                                      // bLength
+                0x21,                                   // bDescriptorType
+                0x11, 0x01,                             // bcdHID
+                0,                                      // bCountryCode
+                1,                                      // bNumDescriptors
+                0x22,                                   // bDescriptorType
+                LSB(sizeof(multijoy_report_desc)),      // wDescriptorLength
+                MSB(sizeof(multijoy_report_desc)),
+                // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
+                7,                                      // bLength
+                5,                                      // bDescriptorType
+                (MULTIJOY_ENDPOINT + 2) | 0x80,         // bEndpointAddress
+                0x03,                                   // bmAttributes (0x03=intr)
+                MULTIJOY_SIZE, 0,                       // wMaxPacketSize
+                MULTIJOY_INTERVAL,                      // bInterval
+        #endif
+        #if MULTIJOY_COUNT > 3
+                // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
+                9,                                      // bLength
+                4,                                      // bDescriptorType
+                (MULTIJOY_INTERFACE + 3)                // bInterfaceNumber
+                0,                                      // bAlternateSetting
+                1,                                      // bNumEndpoints
+                0x03,                                   // bInterfaceClass (0x03 = HID)
+                0x00,                                   // bInterfaceSubClass
+                0x00,                                   // bInterfaceProtocol
+                0,                                      // iInterface
+                // HID interface descriptor, HID 1.11 spec, section 6.2.1
+                9,                                      // bLength
+                0x21,                                   // bDescriptorType
+                0x11, 0x01,                             // bcdHID
+                0,                                      // bCountryCode
+                1,                                      // bNumDescriptors
+                0x22,                                   // bDescriptorType
+                LSB(sizeof(multijoy_report_desc)),      // wDescriptorLength
+                MSB(sizeof(multijoy_report_desc)),
+                // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
+                7,                                      // bLength
+                5,                                      // bDescriptorType
+                (MULTIJOY_ENDPOINT + 3) | 0x80,         // bEndpointAddress
+                0x03,                                   // bmAttributes (0x03=intr)
+                MULTIJOY_SIZE, 0,                       // wMaxPacketSize
+                MULTIJOY_INTERVAL,                      // bInterval
+        #endif
+        // Just support up to 4 for now, but theoretically
+        // this could be expanded up to 12 joysticks
+        // changes here also need to be mirrored up in usb_descriptor_list
+#endif // MULTIJOY_INTERFACE
+
 };
 
 
@@ -764,6 +931,24 @@ const usb_descriptor_list_t usb_descriptor_list[] = {
         {0x2200, JOYSTICK_INTERFACE, joystick_report_desc, sizeof(joystick_report_desc)},
         {0x2100, JOYSTICK_INTERFACE, config_descriptor+JOYSTICK_DESC_OFFSET, 9},
 #endif
+#ifdef MULTIJOY_INTERFACE
+        #if MULTIJOY_COUNT > 0
+                {0x2200, (MULTIJOY_INTERFACE + 0), multijoy_report_desc, sizeof(multijoy_report_desc)},
+                {0x2100, (MULTIJOY_INTERFACE + 0), config_descriptor+MULTIJOY_DESC_OFFSET, 9},
+        #endif
+        #if MULTIJOY_COUNT > 1
+                {0x2200, (MULTIJOY_INTERFACE + 1), multijoy_report_desc, sizeof(multijoy_report_desc)},
+                {0x2100, (MULTIJOY_INTERFACE + 1), config_descriptor+MULTIJOY_DESC_OFFSET, 9},
+        #endif
+        #if MULTIJOY_COUNT > 2
+                {0x2200, (MULTIJOY_INTERFACE + 2), multijoy_report_desc, sizeof(multijoy_report_desc)},
+                {0x2100, (MULTIJOY_INTERFACE + 2), config_descriptor+MULTIJOY_DESC_OFFSET, 9},
+        #endif
+        #if MULTIJOY_COUNT > 3
+                {0x2200, (MULTIJOY_INTERFACE + 3), multijoy_report_desc, sizeof(multijoy_report_desc)},
+                {0x2100, (MULTIJOY_INTERFACE + 3), config_descriptor+MULTIJOY_DESC_OFFSET, 9},
+        #endif
+#endif
 #ifdef RAWHID_INTERFACE
 	{0x2200, RAWHID_INTERFACE, rawhid_report_desc, sizeof(rawhid_report_desc)},
 	{0x2100, RAWHID_INTERFACE, config_descriptor+RAWHID_DESC_OFFSET, 9},
diff --git a/teensy3/usb_desc.h b/teensy3/usb_desc.h
index c013d61..2c43517 100644
--- a/teensy3/usb_desc.h
+++ b/teensy3/usb_desc.h
@@ -194,6 +194,7 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define ENDPOINT6_CONFIG	ENDPOINT_TRANSIMIT_ONLY
 
 #elif defined(USB_SERIAL_HID_JOY)
+  #define MULTIJOY_COUNT	4
   #define VENDOR_ID		0x16C0
   #define PRODUCT_ID		0x0487
   #define DEVICE_CLASS		0xEF
@@ -204,9 +205,9 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define PRODUCT_NAME		{'S','e','r','i','a','l','/','K','e','y','b','o','a','r','d','/','2','x','J','o','y','s','t','i','c','k'}
   #define PRODUCT_NAME_LEN	26
   #define EP0_SIZE		64
-  #define NUM_ENDPOINTS		6
+  #define NUM_ENDPOINTS		4 + MULTIJOY_COUNT
   #define NUM_USB_BUFFERS	30
-  #define NUM_INTERFACE		5
+  #define NUM_INTERFACE		2 + MULTIJOY_COUNT
   #define CDC_IAD_DESCRIPTOR	1
   #define CDC_STATUS_INTERFACE	0
   #define CDC_DATA_INTERFACE	1	// Serial
@@ -220,24 +221,33 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define KEYBOARD_ENDPOINT     1
   #define KEYBOARD_SIZE         8
   #define KEYBOARD_INTERVAL     1
-  #define JOYSTICK2_INTERFACE   3	// Second Joystick
-  #define JOYSTICK2_ENDPOINT    5
-  #define JOYSTICK2_SIZE        16
-  #define JOYSTICK2_INTERVAL    1
-  #define JOYSTICK_INTERFACE    4	// Joystick
-  #define JOYSTICK_ENDPOINT     6
-  #define JOYSTICK_SIZE         16
-  #define JOYSTICK_INTERVAL     1
+  #define MULTIJOY_INTERFACE    3
+  #define MULTIJOY_ENDPOINT     5
+  #define MULTIJOY_SIZE         16
+  #define MULTIJOY_INTERVAL     1
   #define KEYBOARD_DESC_OFFSET	(9+8 + 9+5+5+4+5+7+9+7+7 + 9)
-  #define JOYSTICK2_DESC_OFFSET	(9+8 + 9+5+5+4+5+7+9+7+7 + 9+9+7 + 9+9+7 + 9)
-  #define JOYSTICK_DESC_OFFSET	(9+8 + 9+5+5+4+5+7+9+7+7 + 9+9+7 + 9+9+7 + 9)
-  #define CONFIG_DESC_SIZE	(9+8 + 9+5+5+4+5+7+9+7+7 + 9+9+7 + 9+9+7 + 9+9+7)
+  #define MULTIJOY_DESC_OFFSET	(9+8 + 9+5+5+4+5+7+9+7+7 + 9+9+7 + 9)
+  #define MULTIJOY_DESC_SIZE	(9+9+7)
+  #define CONFIG_DESC_SIZE	(9+8 + 9+5+5+4+5+7+9+7+7 + 9+9+7 + MULTIJOY_HID_DESC_SIZE * MULTIJOY_COUNT)
   #define ENDPOINT1_CONFIG	ENDPOINT_TRANSIMIT_ONLY
   #define ENDPOINT2_CONFIG	ENDPOINT_TRANSIMIT_ONLY
   #define ENDPOINT3_CONFIG	ENDPOINT_RECEIVE_ONLY
   #define ENDPOINT4_CONFIG	ENDPOINT_TRANSIMIT_ONLY
   #define ENDPOINT5_CONFIG	ENDPOINT_TRANSIMIT_ONLY
   #define ENDPOINT6_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT7_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT8_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  // In case we eventually want more than 4
+  // The eventual include of these checks against NUM_ENDPOINTS
+  // So this should be perfectly safe
+  #define ENDPOINT9_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT10_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT11_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT12_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT13_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT14_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT15_CONFIG	ENDPOINT_TRANSIMIT_ONLY
+  #define ENDPOINT16_CONFIG	ENDPOINT_TRANSIMIT_ONLY
 
 #elif defined(USB_MIDI)
   #define VENDOR_ID		0x16C0
diff --git a/teensy3/usb_inst.cpp b/teensy3/usb_inst.cpp
index 67e38a5..94f325f 100644
--- a/teensy3/usb_inst.cpp
+++ b/teensy3/usb_inst.cpp
@@ -53,10 +53,8 @@ uint8_t usb_joystick_class::manual_mode = 0;
 #ifdef USB_SERIAL_HID_JOY
 usb_serial_class Serial;
 usb_keyboard_class Keyboard;
-usb_joystick2_class Joystick2;
-uint8_t usb_joystick2_class::manual_mode = 0;
-usb_joystick_class Joystick;
-uint8_t usb_joystick_class::manual_mode = 0;
+usb_multi_joystick_class MultiJoystick;
+uint8_t usb_multi_joystick_class::manual_mode = 0;
 #endif
 
 #ifdef USB_MIDI
diff --git a/teensy3/usb_joystick.h b/teensy3/usb_joystick.h
index a35486d..0775519 100644
--- a/teensy3/usb_joystick.h
+++ b/teensy3/usb_joystick.h
@@ -31,7 +31,7 @@
 #ifndef USBjoystick_h_
 #define USBjoystick_h_
 
-#if defined(USB_HID) || defined(USB_SERIAL_HID) || defined(USB_SERIAL_HID_JOY)
+#if defined(USB_HID) || defined(USB_SERIAL_HID)
 
 #include <inttypes.h>
 
--- teensy3/usb_joystick.c	2016-09-10 11:56:53.600588600 -0700
+++ teensy3/usb_multijoy.c	2016-09-10 13:23:42.602225000 -0700
@@ -29,15 +29,15 @@
  */
 
 #include "usb_dev.h"
-#include "usb_joystick.h"
+#include "usb_multijoy.h"
 #include "core_pins.h" // for yield()
 #include "HardwareSerial.h"
 #include <string.h> // for memcpy()
 
-#ifdef JOYSTICK_INTERFACE // defined by usb_dev.h -> usb_desc.h
+#ifdef MULTIJOY_INTERFACE // defined by usb_dev.h -> usb_desc.h
 
 
-uint32_t usb_joystick_data[3];
+uint32_t usb_multijoy_data[MULTIJOY_COUNT][3];
 
 
 // Maximum number of transmit packets to queue so we don't starve other endpoints for memory
@@ -59,7 +59,7 @@
 
 
 
-int usb_joystick_send(void)
+int usb_multijoy_send(uint8_t joynum)
 {
         uint32_t wait_count=0;
         usb_packet_t *tx_packet;
@@ -71,7 +71,10 @@
 			//serial_print("error1\n");
                         return -1;
                 }
-                if (usb_tx_packet_count(JOYSTICK_ENDPOINT) < TX_PACKET_LIMIT) {
+                if (joynum >= MULTIJOY_COUNT) {
+                        return -1;
+                }
+                if (usb_tx_packet_count(MULTIJOY_ENDPOINT + joynum) < TX_PACKET_LIMIT) {
                         tx_packet = usb_malloc();
                         if (tx_packet) break;
                 }
@@ -83,9 +86,9 @@
                 yield();
         }
 	transmit_previous_timeout = 0;
-	memcpy(tx_packet->buf, usb_joystick_data, 12);
+	memcpy(tx_packet->buf, usb_multijoy_data[joynum], 12);
         tx_packet->len = 12;
-        usb_tx(JOYSTICK_ENDPOINT, tx_packet);
+        usb_tx(MULTIJOY_ENDPOINT + joynum, tx_packet);
 	//serial_print("ok\n");
         return 0;
 }
@@ -93,4 +96,4 @@
 
 
 
-#endif // JOYSTICK_INTERFACE
+#endif // MULTIJOY_INTERFACE
--- teensy3/usb_joystick.h	2016-09-10 13:12:01.357002800 -0700
+++ teensy3/usb_multijoy.h	2016-09-10 13:26:25.107914200 -0700
@@ -28,10 +28,10 @@
  * SOFTWARE.
  */
 
-#ifndef USBjoystick_h_
-#define USBjoystick_h_
+#ifndef USBmultijoy_h_
+#define USBmultijoy_h_
 
-#if defined(USB_HID) || defined(USB_SERIAL_HID)
+#ifdef USB_SERIAL_HID_JOY
 
 #include <inttypes.h>
 
@@ -39,68 +39,68 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-int usb_joystick_send(void);
-extern uint32_t usb_joystick_data[3];
+int usb_multijoy_send(uint8_t joynum);
+extern uint32_t usb_multijoy_data[MULTIJOY_COUNT][3];
 #ifdef __cplusplus
 }
 #endif
 
 // C++ interface
 #ifdef __cplusplus
-class usb_joystick_class
+class usb_multijoy_class
 {
         public:
         void begin(void) { }
         void end(void) { }
 	void button(uint8_t button, bool val) {
 		if (--button >= 32) return;
-		if (val) usb_joystick_data[0] |= (1 << button);
-		else usb_joystick_data[0] &= ~(1 << button);
-		if (!manual_mode) usb_joystick_send();
+                if (val) usb_multijoy_data[joynum][0] |= (1 << button);
+                else usb_multijoy_data[joynum][0] &= ~(1 << button);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void X(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[1] = (usb_joystick_data[1] & 0xFFFFC00F) | (val << 4);
-		if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][1] = (usb_multijoy_data[joynum][1] & 0xFFFFC00F) | (val << 4);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void Y(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[1] = (usb_joystick_data[1] & 0xFF003FFF) | (val << 14);
-		if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][1] = (usb_multijoy_data[joynum][1] & 0xFF003FFF) | (val << 14);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void position(unsigned int x, unsigned int y) {
 		if (x > 1023) x = 1023;
 		if (y > 1023) y = 1023;
-		usb_joystick_data[1] = (usb_joystick_data[1] & 0xFFF00000)
+                usb_multijoy_data[joynum][1] = (usb_multijoy_data[joynum][1] & 0xFFF00000)
 			| (x << 4) | (y << 14);
-		if (!manual_mode) usb_joystick_send();
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void Z(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[1] = (usb_joystick_data[1] & 0x00FFFFFF) | (val << 24);
-		usb_joystick_data[2] = (usb_joystick_data[2] & 0xFFFFFFFC) | (val >> 8);
-		if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][1] = (usb_multijoy_data[joynum][1] & 0x00FFFFFF) | (val << 24);
+                usb_multijoy_data[joynum][2] = (usb_multijoy_data[joynum][2] & 0xFFFFFFFC) | (val >> 8);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void Zrotate(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[2] = (usb_joystick_data[2] & 0xFFFFF003) | (val << 2);
-		if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][2] = (usb_multijoy_data[joynum][2] & 0xFFFFF003) | (val << 2);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void sliderLeft(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[2] = (usb_joystick_data[2] & 0xFFC00FFF) | (val << 12);
-		if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][2] = (usb_multijoy_data[joynum][2] & 0xFFC00FFF) | (val << 12);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void sliderRight(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[2] = (usb_joystick_data[2] & 0x003FFFFF) | (val << 22);
-		if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][2] = (usb_multijoy_data[joynum][2] & 0x003FFFFF) | (val << 22);
+                if (!manual_mode) usb_multijoy_send();
 	}
 	void slider(unsigned int val) {
 		if (val > 1023) val = 1023;
-		usb_joystick_data[2] = (usb_joystick_data[2] & 0x00000FFF)
+                usb_multijoy_data[joynum][2] = (usb_multijoy_data[joynum][2] & 0x00000FFF)
 			| (val << 12) | (val << 22);
-		if (!manual_mode) usb_joystick_send();
+                if (!manual_mode) usb_multijoy_send();
 	}
         inline void hat(int dir) {
                 uint32_t val;
@@ -113,22 +113,72 @@
                 else if (dir < 245) val = 5;
                 else if (dir < 293) val = 6;
                 else if (dir < 338) val = 7;
-		usb_joystick_data[1] = (usb_joystick_data[1] & 0xFFFFFFF0) | val;
-                if (!manual_mode) usb_joystick_send();
+                usb_multijoy_data[joynum][1] = (usb_multijoy_data[joynum][1] & 0xFFFFFFF0) | val;
+                if (!manual_mode) usb_multijoy_send();
+        }
+        inline void axis(uint8_t axisnum, uint16_t val) {
+                uint8_t bytenum, bitoffset, lowshift;
+                uint8_t lowmask, highmask;
+                if (val > 1023) val = 1023;
+
+                switch(axisnum) {
+                  case 1:
+                        X(val); break;
+                  case 2:
+                        Y(val); break;
+                  case 3:
+                        Z(val); break;
+                  case 4:
+                        Zrotate(val); break;
+                  case 5:
+                        sliderLeft(val); break;
+                  case 6:
+                        sliderRight(val); break;
+                  default:
+                }
+
+                /*
+                 * Old fancy way - still needs updating
+                 * with lowmask/highmask, I believe
+                 * Worth it? Only if we want to support arbitrary # of axes,
+                 * which I doubt HID does anyway
+                 *
+                //TODO: Precalculate these somewhere?
+                //Axis values are 10 bits each, starting at the upper nibble of byte 4 (byte 4, bit 4)
+                //(all above are zero-indexed)
+                bitoffset = 4*8 + 4 + (axisnum * 10);
+                dwordnum = bitoffset >> 1;
+
+                lowshift = bitoffset % 8;
+
+                lowmask = ~(0xFF << lowshift);
+                highmask = (~lowmask) << 2;
+
+                usb_multijoy_data[joynum][dwordnum] = (usb_multijoy_data[joynum][dwordnum] & lowmask) | (val << lowshift);
+                usb_multijoy_data[joynum][dwordnum+1] = (usb_multijoy_data[joynum][dwordnum+1] & highmask) | (val >> (8 - lowshift));
+                */
+                if (!manual_mode) send_now();
         }
 	void useManualSend(bool mode) {
 		manual_mode = mode;
 	}
+        void setJoyNum(uint8_t num) {
+                joynum = num;
+        }
+        void num_joys(void) {
+                return MULTIJOY_COUNT;
+        }
 	void send_now(void) {
-		usb_joystick_send();
+                usb_multijoy_send(joynum);
 	}
 	private:
 	static uint8_t manual_mode;
+        static uint8_t joynum;
 };
-extern usb_joystick_class Joystick;
+extern usb_multijoy_class MultiJoystick;
 
 #endif // __cplusplus
 
 #endif // USB_HID || USB_SERIAL_HID || USB_SERIAL_HID_JOY
-#endif // USBjoystick_h_
+#endif // USBmultijoy_h_
 
